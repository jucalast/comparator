import { Product } from '../types';
import { SupplierProcessor } from './supplierInterface';
import { normalizeProductDetails } from '../utils/productNormalizer';

/**
 * Processador espec√≠fico para o fornecedor Rei das Caixas
 */
export class ReiDasCaixasProcessor implements SupplierProcessor {
  name = 'Rei das Caixas';
  
  /**
   * Verifica se o texto pode ser processado por este fornecedor
   */
  canProcess(text: string): boolean {
    // Verifica por padr√µes espec√≠ficos do Rei das Caixas
    const hasCrownEmoji = (text.match(/üëë/g) || []).length > 3;
    
    // Amplia os padr√µes de detec√ß√£o
    const hasSupplierName = text.includes('REI DAS CAIXAS') || 
                            text.includes('BOM DIA') ||
                            text.includes('Rei das Caixas');
                            
    const hasProductPattern = text.includes('üëë iPhone') || 
                              text.includes('üëëIPhone') ||
                              text.match(/iPhone\s+\d+\s+(?:PRO|Pro|pro)?(?:\s+(?:MAX|Max|max))?\s+\d+GB/) !== null;
    
    // Log para diagn√≥stico
    console.log('Rei das Caixas - canProcess avalia√ß√£o:', {
      hasCrownEmoji,
      hasSupplierName,
      hasProductPattern,
      resultado: hasCrownEmoji && (hasSupplierName || hasProductPattern)
    });
    
    // Relaxa as condi√ß√µes para aumentar a chance de detec√ß√£o
    return (hasCrownEmoji && (hasSupplierName || hasProductPattern)) || 
           (hasSupplierName && hasProductPattern);
  }
  
  /**
   * Extrai produtos do texto no formato Rei das Caixas
   */
  extractProducts(text: string, source: string): Product[] {
    const products: Product[] = [];
    // Criar um buffer de cores separado para uso tempor√°rio
    let colorBuffer: string[] = [];
    
    try {
      console.log(`Processando texto como Rei das Caixas, ${text.length} caracteres`);
      
      // Divide o texto em linhas para processamento
      const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
      console.log(`Total de ${lines.length} linhas para processamento`);
      
      // Para diagn√≥stico, vamos logar as primeiras linhas
      console.log('Primeiras 10 linhas do texto:');
      lines.slice(0, 10).forEach((line, i) => console.log(`[${i}] "${line}"`));
      
      let currentModel = '';
      let currentStorage = '';
      let currentRegion = '';
      let currentCondition = 'Seminovo'; // Padr√£o conforme mencionado no texto "Seminovo"
      let currentPrice = 0;
      let currentDetails: any = {};
      let inProductSection = false;
      
      // Processa linha por linha
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        // Detecta in√≠cio da se√ß√£o de produtos - ampliado para mais padr√µes
        if (line.includes('üëë Seminovo') || line.includes('BOM DIA') || 
            line.includes('Seminovo') || line.includes('SEM DETALHES') ||
            line.includes('SEM ACESS√ìRIOS')) {
          inProductSection = true;
          console.log(`Se√ß√£o de produtos iniciada na linha ${i}: "${line}"`);
          continue;
        }
        
        // For√ßar o processo para come√ßar mesmo sem se√ß√£o explicitamente marcada
        if (i > 10 && !inProductSection && line.match(/üëë\s*(?:i|I)Phone\s+\d+/)) {
          inProductSection = true;
          console.log(`Se√ß√£o de produtos for√ßada na linha ${i}: "${line}"`);
        }
        
        // Se ainda n√£o entramos na se√ß√£o de produtos, continua
        if (!inProductSection) continue;
        
        // Detecta linha de produto (padr√£o ampliado)
        // ex: "üëë iPhone 15 PRO Max 512GB (NUNCA FOI ATIVADO)" ou "üëëIPhone 15 PRO Max 256GB"
        const productMatch = line.match(/^üëë\s*(?:i|I)Phone\s+\d+/);
        
        // Padr√£o alternativo sem emoji para caso a formata√ß√£o do texto seja alterada
        const altProductMatch = !productMatch && line.match(/^(?:i|I)Phone\s+\d+\s+(?:PRO|Pro|pro)?(?:\s+(?:MAX|Max|max))?\s+\d+GB/);
        
        if (productMatch || altProductMatch) {
          console.log(`Produto encontrado na linha ${i}: "${line}"`);
          
          // Reseta os detalhes do produto anterior caso exista
          if (currentModel && currentPrice > 0) {
            // Adiciona os produtos com as cores anteriores antes de resetar
            addProductsWithColors(products, currentDetails, currentPrice, source, colorBuffer);
            // Limpa o buffer de cores ap√≥s adicionar os produtos
            colorBuffer = [];
          }
          
          // Extrai informa√ß√µes do modelo
          const modelInfo = extractModelInfo(line);
          currentModel = modelInfo.model;
          currentStorage = modelInfo.storage;
          currentRegion = modelInfo.region;
          currentCondition = modelInfo.condition;
          currentPrice = 0; // Reseta o pre√ßo para o novo modelo
          
          console.log(`Modelo extra√≠do: ${currentModel}, Storage: ${currentStorage}, Regi√£o: ${currentRegion}`);
          
          // Prepara os detalhes b√°sicos do produto
          currentDetails = {
            brand: 'Apple',
            model: currentModel,
            storage: currentStorage,
            condition: currentCondition,
            region: currentRegion
          };
          
          // Verifica se a mesma linha j√° cont√©m um pre√ßo
          const priceInLineMatch = line.match(/R\$\s*([\d\.,]+)/);
          if (priceInLineMatch) {
            const priceStr = priceInLineMatch[1].trim();
            currentPrice = normalizePrice(priceStr);
            console.log(`Pre√ßo encontrado na mesma linha: R$ ${currentPrice}`);
          }
          
          continue;
        }
        
        // Detecta linha com pre√ßo (com mais flexibilidade)
        const priceMatch = line.match(/R\$\s*([\d\.,]+)/);
        if (priceMatch && currentModel) {
          // Processa o pre√ßo normalizado
          const priceStr = priceMatch[1].trim();
          currentPrice = normalizePrice(priceStr);
          
          console.log(`Pre√ßo encontrado: R$ ${currentPrice} para ${currentModel}`);
          
          // Se temos um modelo e um pre√ßo mas nenhuma cor, adicionamos com cor padr√£o
          if (colorBuffer.length === 0) {
            console.log(`Nenhuma cor definida para ${currentModel}, usando cor padr√£o`);
            // Verifica se o pre√ßo est√° em uma linha que tamb√©m menciona uma cor
            const lineColors = extractColors(line);
            if (lineColors.length > 0) {
              colorBuffer = lineColors;
              console.log(`Cores encontradas na mesma linha do pre√ßo: ${colorBuffer.join(', ')}`);
            } else {
              // Se n√£o encontramos cores, usamos "N/A" como padr√£o
              colorBuffer = ["N/A"];
            }
          }
          
          // Cria produtos para todas as cores definidas antes deste pre√ßo
          addProductsWithColors(products, currentDetails, currentPrice, source, colorBuffer);
          
          // Reseta as cores e o pre√ßo ap√≥s adicionar os produtos
          colorBuffer = [];
          currentPrice = 0;
          
          continue;
        }
        
        // Detecta linhas de cor com emoji ou texto (padr√£o ampliado)
        if (currentModel && (line.match(/[üü†‚ö´üîµ‚ö™üü£üü°üü¢‚ô•üî¥]/) || 
            line.match(/^[‚ö´üîµ‚ö™üü£üü°üü¢‚ô•üî¥]/) || 
            line.match(/^(PRETO|BRANCO|AZUL|VERMELHO|DOURADO|VERDE|ROXO)/i) ||
            line.toLowerCase().includes('preto') ||
            line.toLowerCase().includes('azul') ||
            line.toLowerCase().includes('branco'))) {
            
          // Extrair cores da linha
          const colors = extractColors(line);
          
          // Adiciona as cores para processamento posterior
          if (colors.length > 0 && !line.includes('R$')) {
            colorBuffer.push(...colors);
            console.log(`Cores encontradas: ${colors.join(', ')} para ${currentModel}`);
          }
          
          continue;
        }
      }
      
      // Verificar se ainda h√° um produto pendente para adicionar no final
      if (currentModel && currentPrice > 0) {
        if (colorBuffer.length === 0) {
          colorBuffer = ["N/A"]; // Usa cor padr√£o se nenhuma foi definida
        }
        addProductsWithColors(products, currentDetails, currentPrice, source, colorBuffer);
      }
      
      console.log(`Total de ${products.length} produtos extra√≠dos do fornecedor Rei das Caixas`);
      
      // Abordagem alternativa: busca direta por padr√µes de produtos
      if (products.length === 0) {
        console.log(`Tentando abordagem alternativa para Rei das Caixas`);
        products.push(...this.extractProductsAlternative(text, source));
      }
      
      // Se nenhum produto foi encontrado, registra informa√ß√µes para diagn√≥stico
      if (products.length === 0) {
        console.error('Nenhum produto encontrado no texto do Rei das Caixas.');
        console.error('Problemas poss√≠veis:');
        console.error('1. Formato diferente do esperado');
        console.error('2. Falha nos padr√µes de detec√ß√£o de produto/pre√ßo/cor');
        
        // Verifica se o texto cont√©m alguns padr√µes chave
        const hasIPhone = lines.some(line => line.includes('iPhone') || line.includes('IPHONE'));
        const hasPrice = lines.some(line => line.includes('R$'));
        
        console.error(`- Cont√©m iPhone: ${hasIPhone}`);
        console.error(`- Cont√©m pre√ßos (R$): ${hasPrice}`);
      }
      
    } catch (error) {
      console.error('Erro ao processar texto do Rei das Caixas:', error);
    }
    
    return products;
  }
  
  /**
   * M√©todo alternativo para extrair produtos usando uma abordagem de regex mais agressiva
   */
  private extractProductsAlternative(text: string, source: string): Product[] {
    const products: Product[] = [];
    console.log('Usando abordagem alternativa para extra√ß√£o de produtos');
    
    try {
      // Procura padr√µes de produto completos em uma √∫nica linha
      // iPhone 15 PRO Max 512GB ... R$ 6500
      const productPricePattern = /(?:üëë\s*)?(?:i|I)Phone\s+(\d+(?:\s+(?:Pro|PRO|pro))?(?:\s+(?:Max|MAX|max))?)\s+(\d+(?:GB|TB)).*?(?:Americano|Dubai|Swap)?.*?R\$\s*([\d\.,]+)/g;
      
      let match;
      let count = 0;
      
      // Loop atrav√©s de todos os matches
      while ((match = productPricePattern.exec(text)) !== null) {
        count++;
        const modelName = match[1].trim();
        const storage = match[2].replace(/\s+/g, '');
        const priceStr = match[3].trim();
        const fullLine = match[0];
        
        const price = normalizePrice(priceStr);
        
        if (!isNaN(price) && price > 0) {
          // Determina a regi√£o
          const region = fullLine.includes('Americano') || fullLine.includes('AMERICANO') ? 'USA' : 
                         fullLine.includes('Dubai') || fullLine.includes('DUBAI') ? 'Dubai' : '';
                       
          // Determina a condi√ß√£o
          let condition = 'Seminovo';
          if (fullLine.includes('Swap') || fullLine.includes('SWAP')) {
            condition = 'Swap';
          } else if (fullLine.includes('NUNCA FOI ATIVADO')) {
            condition = 'Novo';
          }
          
          // Extrai cor
          const colors = extractColors(fullLine);
          const color = colors.length > 0 ? colors[0] : 'N/A';
          
          // Detalhes do produto
          const details = {
            brand: 'Apple',
            model: `iPhone ${modelName}`,
            storage,
            color,
            condition,
            region
          };
          
          // Normaliza o c√≥digo
          const { normalizedCode, normalizedDescription } = normalizeProductDetails(details);
          
          // Adiciona o produto
          products.push({
            code: normalizedCode,
            description: `iPhone ${modelName} ${storage} ${color} - Rei das Caixas`,
            price,
            source: `Rei das Caixas`,
            details
          });
          
          console.log(`Produto alternativo extra√≠do: iPhone ${modelName} ${storage} ${color} - R$ ${price}`);
        }
      }
      
      console.log(`Abordagem alternativa encontrou ${count} padr√µes e extraiu ${products.length} produtos`);
      
    } catch (error) {
      console.error('Erro na extra√ß√£o alternativa:', error);
    }
    
    return products;
  }
}

/**
 * Extrai informa√ß√µes do modelo a partir da linha de texto
 */
function extractModelInfo(line: string): { 
  model: string; 
  storage: string; 
  region: string;
  condition: string;
} {
  // Valores padr√£o
  let model = '';
  let storage = '';
  let region = '';
  let condition = 'Seminovo';
  
  // Remove o emoji e espa√ßos iniciais
  const cleanLine = line.replace(/^üëë\s*/, '').trim();
  console.log(`Linha limpa para extra√ß√£o de modelo: "${cleanLine}"`);
  
  // Extrai o modelo e storage (padr√£o ampliado)
  // Tenta capturar v√°rios formatos de modelo, como:
  // "iPhone 15 PRO Max 512GB", "IPhone 14 Pro 128GB Americano", etc.
  const modelMatch = cleanLine.match(/(?:i|I)Phone\s+(\d+(?:\s+(?:Pro|PRO|pro))?(?:\s+(?:Max|MAX|max))?)\s+(\d+(?:GB|TB))/i);
  
  if (modelMatch) {
    model = `iPhone ${modelMatch[1].trim()}`;
    storage = modelMatch[2].trim().replace(/\s+/g, '');
    console.log(`Modelo capturado: ${model}, Storage: ${storage}`);
  } else {
    // Tenta um padr√£o alternativo se o primeiro falhar
    const altMatch = cleanLine.match(/(?:i|I)Phone\s+([^\d]+?\s+\d+|\d+\s+[^\d]+?)\s+(\d+(?:GB|TB))/i);
    if (altMatch) {
      model = `iPhone ${altMatch[1].trim()}`;
      storage = altMatch[2].trim().replace(/\s+/g, '');
      console.log(`Modelo alternativo capturado: ${model}, Storage: ${storage}`);
    } else {
      console.warn(`N√£o foi poss√≠vel extrair modelo/storage de: "${cleanLine}"`);
    }
  }
  
  // Verifica se √© americano, dubai ou swap
  if (cleanLine.includes('Americano') || cleanLine.includes('AMERICANO') || cleanLine.includes('üá∫üá∏')) {
    region = 'USA';
  } else if (cleanLine.includes('Dubai') || cleanLine.includes('DUBAI')) {
    region = 'Dubai';
  }
  
  // Verifica se √© Swap
  if (cleanLine.includes('Swap') || cleanLine.includes('SWAP')) {
    condition = 'Swap';
  } else if (cleanLine.includes('NUNCA FOI ATIVADO')) {
    condition = 'Novo';
  }
  
  return { model, storage, region, condition };
}

/**
 * Extrai cores a partir de uma linha de texto com emojis
 */
function extractColors(line: string): string[] {
  const colors: string[] = [];
  const colorPatterns = [
    { emoji: '‚ö´', name: 'BLACK' },
    { emoji: 'üîµ', name: 'BLUE' },
    { emoji: '‚ö™', name: 'WHITE' },
    { emoji: 'üü†', name: 'ORANGE' },
    { emoji: 'üü£', name: 'PURPLE' },
    { emoji: 'üü°', name: 'GOLD' },
    { emoji: 'üü¢', name: 'GREEN' },
    { emoji: '‚ô•', name: 'RED' },
    { emoji: 'üî¥', name: 'RED' },
    { emoji: 'üíõ', name: 'GOLD' },
    { emoji: 'üü§', name: 'BROWN' },
    { emoji: '‚ö™', name: 'WHITE' },
  ];
  
  // Procura cada padr√£o de cor na linha
  for (const pattern of colorPatterns) {
    if (line.includes(pattern.emoji)) {
      // Verifica se h√° um nome espec√≠fico ap√≥s o emoji
      const regex = new RegExp(`${pattern.emoji}\\s*([A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]+)`, 'i');
      const match = line.match(regex);
      
      if (match) {
        // Usa o nome da cor mencionado no texto
        colors.push(match[1].trim().toUpperCase());
      } else {
        // Usa o nome padr√£o da cor
        colors.push(pattern.name);
      }
    }
  }
  
  // Tamb√©m verifica nomes de cores espec√≠ficos sem emoji
  const colorNames = [
    'preto', 'midnight', 'graphite', 'branco', 'azul', 'vermelho', 'verde', 
    'roxo', 'lil√°s', 'rose', 'dourado', 'natural'
  ];
  
  for (const colorName of colorNames) {
    if (line.toLowerCase().includes(colorName)) {
      colors.push(normalizeColor(colorName));
    }
  }
  
  return [...new Set(colors)]; // Remove duplicatas
}

/**
 * Normaliza o nome da cor
 */
function normalizeColor(colorText: string): string {
  const colorMap: Record<string, string> = {
    'preto': 'BLACK',
    'midnight': 'BLACK',
    'graphite': 'BLACK',
    'branco': 'WHITE',
    'starlight': 'WHITE',
    'azul': 'BLUE',
    'vermelho': 'RED',
    'verde': 'GREEN',
    'roxo': 'PURPLE',
    'lil√°s': 'PURPLE',
    'dourado': 'GOLD',
    'rose': 'PINK',
    'rosa': 'PINK',
    'natural': 'NATURAL'
  };
  
  const normalizedColor = colorText.trim().toLowerCase();
  return colorMap[normalizedColor] || normalizedColor.toUpperCase();
}

/**
 * Adiciona produtos √† lista com base nos detalhes e no pre√ßo
 */
function addProductsWithColors(
  products: Product[], 
  details: any, 
  price: number, 
  source: string,
  colorBuffer: string[]
): void {
  if (!details.model || price <= 0) {
    console.log(`Ignorando produto com dados incompletos: Modelo=${details.model}, Pre√ßo=${price}`);
    return;
  }
  
  // Se n√£o tiver cores, adiciona um produto sem cor especificada
  if (colorBuffer.length === 0) {
    const productDetails = { ...details, color: 'N/A' };
    addSingleProduct(products, productDetails, price, source);
    console.log(`Adicionado produto sem cor especificada: ${details.model} ${details.storage}`);
    return;
  }
  
  // Adiciona um produto para cada cor
  for (const color of colorBuffer) {
    const productDetails = { ...details, color };
    addSingleProduct(products, productDetails, price, source);
    console.log(`Adicionado produto com cor ${color}: ${details.model} ${details.storage}`);
  }
}

/**
 * Adiciona um √∫nico produto √† lista
 */
function addSingleProduct(products: Product[], details: any, price: number, source: string): void {
  // Normaliza o c√≥digo usando a fun√ß√£o auxiliar
  const { normalizedCode, normalizedDescription } = normalizeProductDetails(details);
  
  // Cria a descri√ß√£o completa do produto
  let fullDescription = `${details.model} ${details.storage} ${details.color}`;
  if (details.region) {
    fullDescription += ` (${details.region})`;
  }
  fullDescription += ` - Rei das Caixas`;
  
  // Adiciona o produto √† lista
  products.push({
    code: normalizedCode,
    description: fullDescription,
    price,
    source: `Rei das Caixas`,
    details
  });
  
  console.log(`Produto extra√≠do: ${fullDescription} - R$ ${price}`);
}

/**
 * Normaliza um valor de pre√ßo a partir de uma string
 * Lida com diferentes formatos como R$1.400.00, R$2.990,00, R$6500, etc.
 */
function normalizePrice(priceStr: string): number {
  // Remove poss√≠veis espa√ßos e caracteres n√£o-num√©ricos exceto ponto e v√≠rgula
  const cleaned = priceStr.trim().replace(/[^\d.,]/g, '');
  
  // Verifica se o pre√ßo tem apenas n√∫meros, sem separadores
  if (!cleaned.includes('.') && !cleaned.includes(',')) {
    const price = parseInt(cleaned);
    // Se o valor for maior que 10000, provavelmente est√° em centavos
    return price > 10000 ? price / 100 : price;
  }
  
  // Se termina com dois zeros ap√≥s um ponto (formato R$1.400.00)
  if (/\.\d{2}$/.test(cleaned)) {
    // Substitui todos os pontos exceto o √∫ltimo por nada
    // e o √∫ltimo ponto por v√≠rgula
    const parts = cleaned.split('.');
    const lastPart = parts.pop();
    const firstPart = parts.join('');
    return parseFloat(`${firstPart}.${lastPart}`);
  }
  
  // Se h√° apenas um ponto ou v√≠rgula
  if ((cleaned.match(/\./g) || []).length === 1) {
    return parseFloat(cleaned.replace(',', '.'));
  }
  
  // Para casos com m√∫ltiplos separadores (1.234.56 ou 1,234.56)
  if ((cleaned.match(/\./g) || []).length > 1 || 
      ((cleaned.match(/\./g) || []).length === 1 && (cleaned.match(/,/g) || []).length === 1)) {
    // Assume que o formato √© 1.234.56 (pontos como separadores de milhar e decimal)
    const parts = cleaned.split('.');
    const lastPart = parts.pop();
    const firstPart = parts.join('');
    return parseFloat(`${firstPart}.${lastPart}`);
  }
  
  // Fallback: substitui v√≠rgula por ponto e converte
  return parseFloat(cleaned.replace(/\./g, '').replace(',', '.'));
}
